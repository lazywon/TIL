## 리액트 상태관리 라이브러리

### Context API

- 한계
  - 반복적이고 복잡한 업데이트에 사용할 경우 비효율적임
  - 데이터 서브셋을 대상으로 변경을 감지하고 업데이트할 수 없음. Provider 하위의 모든 consumer들은 Provider 속성이 변경될 때마다 다시 렌더링 된다.
  - 결론: context api 는 상태관리 도구로 사용하면 props drilling 을 회피한다는 장점보다 잃는 것이 더 많다. `Context API는 상태 관리로는 사용하지 않는 것이 좋을것 같다.`
- 그럼에도 상태관리 도구로 Contest API를 쓰는 이유?
  - 전역 상태 관리 도구를 사용하지 않으면 props drilling으로 각 컴포넌트들의 상태를 관리해야 함
  - 간혹 상태값이 필요한 컴포넌트와 부모 컴포넌트 사이의 중간 컴포넌트가 존재하는 경우가 있음. 그 중간 컴포넌트는 부모와 자식의 상태를 매개하기 위해서만 props를 받는다. 이런 중간 컴포넌트가 많아지면 redux의 보일러플레이트 만큼 코드량도 늘어난다.
  - Context API를 쓰면 중간 컴포넌트를 건너뛰고 바로 대상으로 하는 컴포넌트로 전달 가능하다.
  - 그러나 `react-redux`도 context API 사용했다가 다시 각 컴포넌트가 store를 직접 구독하는 방식으로 변경함
- 언제 Context API를 사용하는것이 좋은가?
  - `정적인 값에 가까운 값을 props drilling 대신 사용하는 데 유용하다.`
  - 즉, provider 내부에서 상태 변경이 거의 일어나지 않는다면, 해당 상태를 provider 하위 다른 컴포넌트에 전달하는 용도로 쓰는데 적합하다.
  - 예시로 locale이나 theme 정보가 있다.
  - 또는 거의 상태변경이 일어나지 않으면서 전역적으로 사용이 필요한 객체 초기화하는 용도로도 적합하다.
    - 이 경우 장점
      - 테스트 코드 작성 시 provider 감싸주는 것으로 mocking을 대신할 수 있음. (물론 이 경우 초기화하는 개체에 테스트가 의존성을 가지기 때문에 유닛 테스트 대신 통합 테스트에 어울린다.)
      - context의 provider가 인터페이스 역할을 하면서 컴포넌트 간 결합성이 낮아지고, provider를 교체하는 것만으로 훗날 명세 변경에 대응할 수 있음

### Redux

- 특징
  - 가장 처음 나온 상태 관리 라이브러리
  - 중앙 집중식 Storage와 상태 업데이트를 위한 Reducer를 사용하며, 단방향 데이터 흐름을 따른다.
- 장점
  - 비교적 오래된 역사로 탄탄한 커뮤니티와 개발자 풀이 존재
  - 보일러플레이트가 많고 다양함
  - 미들웨어를 활용하여 여러 비동기, 로그 작업 등 처리할 수 있으며, 이때 Redux를 위한 라이브러리 사용하여 더 쉽게 구현 가능
  - 단방향 데이터 흐름을 따르기에 Reducer 등의 단위 테스트가 비교적 쉬움
- 단점
  - 구조가 너무 복잡하여 생기는 여러 문제가 있음
    - 간단한 웹앱 개발시에도 Action, Reducer, Action Creator 등 코드 모두 작성해야 하며, 러닝커브가 높음
    - Recoil, MobX와 달리 state가 변경될 때 Component를 업데이트 해주는 반응형 메커니즘이 기본적으로 탑재되어 있지 않아, React 자체 메커니즘을 활용하거나 추가 외부 라이브러리 사용해야 함

### Recoil

- 특징
  - Facebook사에서 개발
  - 가장 React스러운 상태관리라는 철학을 갖고 있음
  - javascript로 작성됨
  - bottom-up 방식: atom 단위로 상태 관리

* 장점
  - 배우기 쉬움. 이전에 hook을 사용했다면 Recoil을 쉽게 이해할 수 있음
  - 컴포넌트가 사용하는 데이터 조각만 사용할 수 있음
  - 계산된 selector를 선언할 수 있음
  - 비동기 데이터 흐름을 위한 내장 솔루션 제공
  - 즉, 비동기 데이터, 상태 지속성, 매개변수화된 selector를 처리할 수 있는 솔루션을 제공
  - React 동시성 모드에 대한 지원도 될 것
  * Component가 렌더링 되는 시기, 상태 등을 세밀하게 제어할 수 있음. 이를 이용하여 성능 최적화 가능
  * Redux와 달리 Reactive 메커니즘 탑재하고 있어 동적인 기능을 좀 더 쉽게 구현 가능
* 단점
  - 비교적 최신 라이브러리이다 보니, 커뮤니티가 비교적 빈약하며, 이슈나 버그 발생 시 홀로 해결해야 하는 경우가 생길 수 있음
  - 시작하기는 쉬우나 Recoil 상태관리 자체가 세분화되어 있어 초심자가 디버깅하거나 테스트 진행하기 어려움
  - Facebook 개발진들이 추친하고있음에도 불구하고 매우 느리게 commit 이루어지는 중이며, 그에 반해 Jotai 와 Zustand 는 굉장히 활발하게 업데이트가 이루어지고 있음

### MobX

- 특징
  - Redux의 여러 문제점을 보완하여 나온 상태관리 라이브러리
  - Redux보다 객체 지향적이며, Immutable.js와 같은 불변성 유지하기 위한 라이브러리 굳이 사용할 필요 없음
- 장점
  - Recoil과 마찬가지로 Redux에 비해 더 쉬운 러닝커브를 가짐. 객체 지향적이고 캡슐화를 지원하기에 개발자친화적임
  - Redux에서 제공하지 않는 반응형 메커니즘을 제공하여 좀 더 쉽게 동적 웹앱 개발 가능
- 단점
  - 웹앱 규모가 커지면서 로직이 MobX의 자동 업데이트에 의존하기에 디버깅이 어려워짐
  - Redux 만킄 커뮤니티가 크지 않음
  - Validation 구현에 있어 코드가 번잡스럽다고 알려짐

### Jotai

- 특징
  - Context의 re-rendering 문제를 해결하기 위해 만들어진 React 특화 상태관리 라이브러리
  - Recoil 기반으로, 함수형 프로그래밍(state, useState) 및 Context API 형태의 코드 패턴
- 장점
  - 경량화된 API
  - Jotai의 atom은 Recoil과 달리 String key가 따로 필요 없음
  - 타입스크립트 기반
  - utils 함수들 제공
  - Suspense(Concurrent mode)를 적용하는데에 적합하게 설계 됨

### Zustand

- 특징
  - Redux 기반
- 장점
  - 타입스크립트 기반
  - 보일러플레이트가 거의 없음
  - Context API와 달리 상태 변경 시 불필요한 리렌더링 일으키지 않도록 제어하기 쉬움
  - 간결한 초기설정과 직관적이고 복잡하지 않은 전역변수를 다루는데 유용함
  - Redux와 달리 providers로 감싸주지 않아도 됨

## 패턴 유형

### Proxy 패턴 - Mobx

- `전체 상태들 모아놓고 엑세스를 제공`하며, 컴포넌트에서 사용되는 일부 상태를 `자동으로 감지하고 업데이트를 인지`하는 패턴
- 단순한 패턴인만큼 디버깅이 어려움
- `Store 데이터에 바로 엑세스하여 변경하는 편의성`이 있음

### Flux 패턴 - Redux, Zustand

- `Store라는 상태 저장소 기반`으로, Action 타입을 Reducer에 전달하면 해당 타입에 맞는 동작에 따라 상태값 갱신
- 컴포넌트는 Selector를 사용해 Store에서 필요한 상태값을 구독(Subscribing)하는 형태를 보임
- 상태가 분리되어 있으며, 단방향 플로우라는 점이 `유지보수에 용이`하다.
- 하지만 그만큼 `보일러 플레이트와 작성할 코드가 방대`해진다는 단점이 있음

### Atomic 패턴 - Recoil, Jotai

- React의 state와 비슷하게 `컴포넌트 트리 안에 상태들이 존재`하며, 이들이 `상향식(bottom-up)`으로 수집 및 공유되는 패턴
- 상태들은 atom이라 불리는 객체에서 설정하며, 값의 참조와 조작은 React.useStae와 유사한 방식으로 수행
- Store에서 하향식으로 관리되던 기존 패턴과 매우 달라, 다른 라이브러리보다는 React의 Hooks 및 Context API와 비교됨

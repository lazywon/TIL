# 리액트 상태관리 라이브러리

## 상태 관리 라이브러리의 필요성

- 전역 상태 관리
- 여러 컴포넌트 간 통신 단순화
  - 서로 다른 두 컴포넌트에 같은 데이터가 필요한 경우, 부모 자식 관계가 아닌 이상 각 컴포넌트 간 직접적인 데이터 전달이 어려움
    - 데이터를 부모로 보내고 다시 그 데이터가 필요한 자식 컴포넌트로 전달 .. (상태 끌어올리기)
  - 하나의 어플리케이션 안에 여러 컴포넌트에 데이터를 전달해야 하는 경우 `props-drilling` 현상 발생 → prop 추적에 어려움
- 상태 중앙화
  - 상태 관리 사용하여 중앙에서 데이터 관리하여 상태 관리 단순화
- 캐싱과 성능 최적화
  - 내부적으로 데이터 캐싱 및 업데이트 최적화를 수행하여 애플리케이션 성능 향상
- 비동기 데이터 관리
  - API 호출, 데이터 로딩 처리와 같은 비동기 작업 효율적으로 관리 가능
- 상태 갱신 추적 및 디버깅 할 수 있는 도구 제공

## 전역 상태 관리 라이브러리

### Context API

- Context를 사용하면 트리 단계마다 명시적으로 props를 넘겨주지 않아도 전역으로 데이터를 공유할 수 있다.
- react에서 제공하는 기술이기에 추가 설치가 필요 없음
- Context의 주된 목적은 `단순히 Props Drilling을 방지`하는 것.
  - Context API는 상태 관리 도구가 아님. 상태 관리 자체는 직접 관리해야 한다.
    - 실질적 상태 관리는 **useState**와 **useReducer**로 동작함
      - 상태 관리의 정의
        - 초기 값을 저장한다. (hook을 호출하여 초기 값 저장)
        - 현재 값을 읽을 수 있다. (hook을 호출하여 현재 값 읽기)
        - 값 업데이트가 가능하다. (setState, dispatch 함수 호출하여 값 업데이트)
- 한계

  - 렌더링 이슈
    - provider 하위에서 context를 구독하는 모든 컴포넌트는 provider의 value prop이 바뀔때마다 다시 렌더링 된다.
    - 컴포넌트 state가 변경되면 해당 컴포넌트의 하위도 리렌더링 된다.
      - shouldComponentUpdate 메서드의 최적화 기법이 기본적으로 적용되지 않았음
        - shouldComponentUpdate : 이전 state, props와 현재 state, props 비교하여 달라지지 않았다면 리렌더링하지 않는 최적화를 위한 라이프사이클 메서드
  - 반복적이고 복잡한 업데이트에 사용할 경우 비효율적임
  - 데이터 서브셋을 대상으로 변경을 감지하고 업데이트할 수 없음. Provider 하위의 모든 consumer들은 Provider 속성이 변경될 때마다 다시 렌더링 된다.
  - 해결방법으로 `React.memo`를 provider 내부 모든 컴포넌트에 사용하면 리렌더링 방지할 수 있음
    - but, 같은 props로 렌더링이 자주 일어나는 경우 React.memo의 성능상 이점을 볼 수 있지만, props가 자주 바뀌는 경우 props 비교 함수가 매번 동작하게 되어 과유불급이 될 수 있음
  - 결론: context api 는 상태관리 도구로 사용하면 props drilling 을 회피한다는 장점보다 잃는 것이 더 많다. `Context API는 상태 관리로는 사용하지 않는 것이 좋을것 같다.`

- 그럼에도 상태관리 도구로 Context API를 쓰는 이유?
  - 전역 상태 관리 도구를 사용하지 않으면 props drilling으로 각 컴포넌트들의 상태를 관리해야 함
  - 간혹 상태값이 필요한 컴포넌트와 부모 컴포넌트 사이의 중간 컴포넌트가 존재하는 경우가 있음. 그 중간 컴포넌트는 부모와 자식의 상태를 매개하기 위해서만 props를 받는다. 이런 중간 컴포넌트가 많아지면 redux의 보일러플레이트 만큼 코드량도 늘어난다.
  - Context API를 쓰면 중간 컴포넌트를 건너뛰고 바로 대상으로 하는 컴포넌트로 전달 가능하다.
  - 그러나 `react-redux`도 context API 사용했다가 다시 각 컴포넌트가 store를 직접 구독하는 방식으로 변경함
- 언제 Context API를 사용하는것이 좋은가?
  - `정적인 값에 가까운 값을 props drilling 대신 사용하는 데 유용하다.`
  - 즉, provider 내부에서 상태 변경이 거의 일어나지 않는다면, 해당 상태를 provider 하위 다른 컴포넌트에 전달하는 용도로 쓰는데 적합하다.
  - 예시로 locale이나 theme 정보가 있다.
  - 또는 거의 상태변경이 일어나지 않으면서 전역적으로 사용이 필요한 객체 초기화하는 용도로도 적합하다.
    - 이 경우 장점
      - 테스트 코드 작성 시 provider 감싸주는 것으로 mocking을 대신할 수 있음. (물론 이 경우 초기화하는 개체에 테스트가 의존성을 가지기 때문에 유닛 테스트 대신 통합 테스트에 어울린다.)
      - context의 provider가 인터페이스 역할을 하면서 컴포넌트 간 결합성이 낮아지고, provider를 교체하는 것만으로 훗날 명세 변경에 대응할 수 있음

### Redux

- 애플리케이션의 상태를 하나의 중앙 저장소(store) 한 곳에서 저장/관리하며, 복잡한 상태 관리 문제를 해결하기 위해 고안된 도구
- 특징
  - 가장 처음 나온 상태 관리 라이브러리
  - 중앙 집중식 Storage와 상태 업데이트를 위한 Reducer를 사용하며, 단방향 데이터 흐름을 따른다.
- 장점
  - 비교적 오래된 역사로 탄탄한 커뮤니티와 개발자 풀이 존재
  - 보일러플레이트가 많고 다양함
  - 미들웨어를 활용하여 여러 비동기, 로그 작업 등 처리할 수 있으며, 이때 Redux를 위한 라이브러리 사용하여 더 쉽게 구현 가능
  - 단방향 데이터 흐름을 따르기에 Reducer 등의 단위 테스트가 비교적 쉬움
- 단점
  - 구조가 너무 복잡하여 생기는 여러 문제가 있음
    - 간단한 웹앱 구현 시에도 필수적으로 작성해야 하는 코드들 (Action, Reducer, Action Creator .. )이 있어 방대한 양의 코드를 작성해야 함
    - Redux의 개념과 패턴을 이해하기 위한 러닝 커브가 높은 편
    - Recoil, MobX와 달리 state가 변경될 때 Component를 업데이트 해주는 반응형 메커니즘이 기본적으로 탑재되어 있지 않아, React 자체 메커니즘을 활용하거나 추가 외부 라이브러리 사용해야 함
    - 지나친 중앙 집중화로 인해 프로젝트가 커질수록 어떤 상태를 어디서 변경하는지 추적하기 어려워질 수 있음
- Redux는 대규모 프로젝트나 복잡한 상태 관리가 필요한 경우에 매우 유용할 수 있지만, 작은 규모의 애플리케이션에서 간단한 상태 관리를 위해 Redux를 도입하면 오히려 복잡성만 늘어날 수 있다.
- 그럼 언제 사용해야 할까?
  - 여러 위치에 많은 양의 상태 값이 존재 할 때
  - 업데이트 로직이 복잡 할 때
  - 거대한 코드 베이스를 여러 사람이 작업 할 때
  - 상태 변경 시각화가 필요 할 때
  - 사이드이펙트, 메모이제이션, 데이터 직렬화등 관리를 위해 더 강력한 기능이 필요 할 때

### Recoil

- 페이스북에서 개발한 상태 관리 라이브러리. Redux, Mobx와 달리 React에서 제공하는 상태 관리 라이브러리
  - Redux, Mobx는 React의 라이브러리가 아님.
  - Recoil은 React의 `Context API 기반으로 구현`됨
- 특징
  - Facebook사에서 개발
  - 가장 React스러운 상태관리라는 철학을 갖고 있음
  - javascript로 작성됨
  - bottom-up 방식: atom 단위로 상태 관리
  - Atom이라는 단위로 상태를 정의하고 이를 조합하여 더 큰 단위의 복잡한 상태를 구성할 수 있음
    - 상태의 구성과 재사용성을 높임

* 장점
  - 간단한 문법, 배우기 쉬움. 이전에 hook을 사용했다면 Recoil을 쉽게 이해할 수 있음
  - 컴포넌트가 사용하는 데이터 조각만 사용할 수 있음
  - 계산된 selector를 선언할 수 있음
  - 비동기 데이터 흐름을 위한 내장 솔루션 제공
  - 즉, 비동기 데이터, 상태 지속성, 매개변수화된 selector를 처리할 수 있는 솔루션을 제공
  - React 동시성 모드에 대한 지원도 될 것
  - 가장 리액트스러운 상태 관리라는 철학을 가짐. → React와 더욱 통합되어 코드 일관성 유지하면서 상태를 관리할 수 있음
  * Component가 렌더링 되는 시기, 상태 등을 세밀하게 제어할 수 있음. 이를 이용하여 성능 최적화 가능
  * Redux와 달리 Reactive 메커니즘 탑재하고 있어 동적인 기능을 좀 더 쉽게 구현 가능
  - Context는 단일 값만 저장 가능하고, 자체 Consumer를 가지는 여러 값들의 집합을 담는 것은 불가함.
    - 이로 인해 state가 존재하는 곳부터 state가 사용되는 곳까지 코드 분할이 어렵다.
    - Recoil은 상태 정의가 증분 및 분산되어 Code Spliting이 가능하다.
* 단점
  - 비교적 최신 라이브러리이다 보니, 커뮤니티가 비교적 빈약하며, 이슈나 버그 발생 시 홀로 해결해야 하는 경우가 생길 수 있음
  - 시작하기는 쉬우나 Recoil 상태관리 자체가 세분화되어 있어 초심자가 디버깅하거나 테스트 진행하기 어려움
  - Facebook 개발진들이 추친하고있음에도 불구하고 매우 느리게 commit 이루어지는 중이며, 그에 반해 Jotai 와 Zustand 는 굉장히 활발하게 업데이트가 이루어지고 있음

### MobX

- 특징
  - Redux의 여러 문제점을 보완하여 나온 상태관리 라이브러리
  - Redux보다 객체 지향적이며, class를 사용할 것을 권장. 데코레이터를 제공하여 깔끔한 구성 가능해짐.
    - 캡슐화 지원
  - Redux는 state 불변성 유지를 위해 여러 라이브러리를 사용하기도 하는데, MobX에서는 그러지 않아도 됨.
    - Immutable.js와 같은 불변성 유지하기 위한 라이브러리 굳이 사용할 필요 없음
- 장점
  - Recoil과 마찬가지로 Redux에 비해 더 쉬운 러닝커브를 가짐. 객체 지향적이고 캡슐화를 지원하기에 개발자친화적임
  - Redux에서 제공하지 않는 반응형 메커니즘을 제공하여 좀 더 쉽게 동적 웹앱 개발 가능
- 단점
  - 웹앱 규모가 커지면서 로직이 MobX의 자동 업데이트에 의존하기에 디버깅이 어려워짐
  - Redux 만큼 커뮤니티가 크지 않고, 함수형 컴포넌트를 사용한 레퍼런스를 찾기 힘들다.
  - Validation 구현에 있어 코드가 번잡스럽다고 알려짐
  - 로직이 MobX의 자동 업데이트에 의존하기에 디버깅이 어렵다.

### Jotai

- 특징
  - Context의 re-rendering 문제를 해결하기 위해 만들어진 React 특화 상태관리 라이브러리
  - Recoil 기반으로, 함수형 프로그래밍(state, useState) 및 Context API 형태의 코드 패턴
- 장점
  - 경량화된 API
  - Jotai의 atom은 Recoil과 달리 String key가 따로 필요 없음
  - 타입스크립트 기반
  - utils 함수들 제공
  - Suspense(Concurrent mode)를 적용하는데에 적합하게 설계 됨

### Zustand

- 특징
  - Redux 기반
- 장점
  - 타입스크립트 기반
  - 보일러플레이트가 거의 없음
  - Context API와 달리 상태 변경 시 불필요한 리렌더링 일으키지 않도록 제어하기 쉬움
  - 간결한 초기설정과 직관적이고 복잡하지 않은 전역변수를 다루는데 유용함
  - Redux와 달리 providers로 감싸주지 않아도 됨

## 패턴 유형

### Proxy 패턴 - Mobx

- `전체 상태들 모아놓고 엑세스를 제공`하며, 컴포넌트에서 사용되는 일부 상태를 `자동으로 감지하고 업데이트를 인지`하는 패턴
- 단순한 패턴인만큼 디버깅이 어려움
- `Store 데이터에 바로 엑세스하여 변경하는 편의성`이 있음

### Flux 패턴 - Redux, Zustand

- `Store라는 상태 저장소 기반`으로, Action 타입을 Reducer에 전달하면 해당 타입에 맞는 동작에 따라 상태값 갱신
- 컴포넌트는 Selector를 사용해 Store에서 필요한 상태값을 구독(Subscribing)하는 형태를 보임
- 상태가 분리되어 있으며, 단방향 플로우라는 점이 `유지보수에 용이`하다.
- 하지만 그만큼 `보일러 플레이트와 작성할 코드가 방대`해진다는 단점이 있음

### Atomic 패턴 - Recoil, Jotai

- React의 state와 비슷하게 `컴포넌트 트리 안에 상태들이 존재`하며, 이들이 `상향식(bottom-up)`으로 수집 및 공유되는 패턴
- 상태들은 atom이라 불리는 객체에서 설정하며, 값의 참조와 조작은 React.useStae와 유사한 방식으로 수행
- Store에서 하향식으로 관리되던 기존 패턴과 매우 달라, 다른 라이브러리보다는 React의 Hooks 및 Context API와 비교됨

---

## 데이터 가져오기/서버 캐싱/상태 관리 도구

- 위 상태 관리 라이브러리들은 클라이언트 상태 관리에는 유용하지만, `서버 상태와 동기화 되지 않기 때문에` 개발자가 직접 상태를 업데이트해 주어야 하는 불편함이 생긴다.
- 이러한 불편함 해소하기 위해 등장한 라이브러리: React-Query, SWR, Apollo Client ..
- 서버 캐싱 도구들도 가져온 데이터를 기반으로 초기 값을 설정하고 hook들을 통해 현재 값을 반환하며 서버 변화를 확인하여 구성요소를 다시 렌더링하기 때문에 `상태 관리` 라고 정의 할 수 있다.

### React-Query

- 리액트 애플리케이션에 서버로부터 데이터를 가져오고, 캐싱/ 동기화/ 업데이트하는 것을 쉽게 해줌
- 주로 REST API, GraphQL 등에서 데이터를 가져오고 관리하는 데 사용
- 가져온 데이터 `자동으로 캐싱`하고, 캐시된 데이터 활용하여 중복 요청 방지
- 지정 간격으로 자동으로 데이터를 다시 가져오는 `인터벌 갱신` 지원
  - 요청이 실패하거나 일시적인 네트워크 문제가 발생한 경우 `자동으로 재시도`하고, `주기적으로 데이터를 업데이트`
  - 조회한 데이터에 대해 업데이트 시 자동으로 최신 데이터로 UI 업데이트 해줌
- API 요청의 `비동기 처리와 에러 핸들링`을 단순화시켜줌. 로딩 상태와 에러 상태 추적할 수 있음

### SWR **(Stale-While-Revalidate)**

- 데이터 가져오기 및 캐싱을 위한 라이브러리
- **Stale-While-Revalidate 패턴 기반**
  - 먼저 캐시된 데이터를 사용하되, 백그라운드에서 새로운 데이터를 가져와 최신 데이터로 갱신하는 전략
- 가볍고 빠른 데이터 흐름을 위해 주로 사용
- React-Query와 유사한 기능 제공하지만 강조하는 캐싱 패턴이 조금 다름
